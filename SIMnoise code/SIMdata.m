function [] = SIMdata(dataparams)
% This m-file is for reading in SIM acquisitions, for 2D/3D, multi-color,
% or time lapse. The data is assumed to be read in from a series of 2D (xy)
% image files, and is stored in a 7D array, according to 
% x/y/phase/z/channel/t/angle. An initial .mat file is read in, which is
% supposed to contain all relevant metadata.
%
% After read-in of all 2D image files a series of preprocessing steps is
% made:
% (1) Make an offset and gain correction.
% (2) Evaluate sum intensities for monitoring photobleaching.
% (3) Assess Modulation Contrast to Noise Ratio (MCNR).
% (3) Apply window for ensuring periodic boundary conditions in FT.
% (4) Do an optional drift correction. This uses the function findshift and
%     shift from the dipimage/diplib toolbox. 
% (5) Split the entire dataset in two noise independent data halves via the
%     random binomial data splitting method (see Methods). 
%
% copyright Carlas Smith & Sjoerd Stallinga, TU Delft, 2017-2020

%%
% check if function is used as script

if nargin < 1
  close all
  clearvars
  is_executed_as_script = true;
  addpath(genpath('./helperfunctions'))
else
  is_executed_as_script = false; 
end

%% Section 1 - load data

% selection dataset(s) to be processed
if is_executed_as_script
  % all datasets for the paper for individual or batch reconstruction
%   allSIMdatasets = {'GFP_zyxin'}; 
%   allSIMdatasets = {'nano_test_structures_chirp'}; 
%   allSIMdatasets = {'nano_test_structures_finepitch'}; 
%   allSIMdatasets = {'mCherry_synaptonemal_complex'}; 
%   allSIMdatasets = {'invitrogen_test_slide'}; 
%   allSIMdatasets = {'20150724_Tub-6_512_T30_30ms_01'};
%   allSIMdatasets = {'20150724_Tub-6_512_T30_10ms_02'}; 
%   allSIMdatasets = {'20150724_Tub-6_512_T10_10ms_03'}; 
  allSIMdatasets = {'20150724_Tub-6_512_T1_30ms_04'};   
%   allSIMdatasets = {'20180212_G-layer_STD_512_T1_30ms_FoV3_46'}; 
%   allSIMdatasets = {'20180212_G-layer_STD_512_T1_30ms_FoV3_47'}; 
%   allSIMdatasets = {'20180212_G-layer_STD_512_T1_100ms_FoV3_48'}; 
%   allSIMdatasets = {'20180212_G-layer_STD_512_T1_100ms_FoV3_49'}; 
%   allSIMdatasets = {'BPAEC_514_488_30ms_T100_405_30ms_T100_593_30ms_T100_03'};
%   allSIMdatasets = {'20171101_3_C127_H3K4me3-rbA488_DAPI_07'};
%   allSIMdatasets = {'20180709_HeLa_H2B-GFP_37C_520_T30_10ms_d2s_06'};
%   allSIMdatasets = {'GFP_zyxin','nano_test_structures_chirp','nano_test_structures_finepitch','mCherry_synaptonemal_complex','invitrogen_test_slide',...
%     '20150724_Tub-6_512_T30_30ms_01','20150724_Tub-6_512_T30_10ms_02','20150724_Tub-6_512_T10_10ms_03','20150724_Tub-6_512_T1_30ms_04',...
%     '20180212_G-layer_STD_512_T1_30ms_FoV3_46','20180212_G-layer_STD_512_T1_30ms_FoV3_47','20180212_G-layer_STD_512_T1_100ms_FoV3_48','20180212_G-layer_STD_512_T1_100ms_FoV3_49',...
%     'BPAEC_514_488_30ms_T100_405_30ms_T100_593_30ms_T100_03','20171101_3_C127_H3K4me3-rbA488_DAPI_07','20180709_HeLa_H2B-GFP_37C_520_T30_10ms_d2s_06'};
else
  allSIMdatasets = dataparams.allSIMdatasets;
end

% loop over all datasets to be processed
for jdataset = 1:numel(allSIMdatasets)
  close all
  SIMdataset = allSIMdatasets{jdataset};

  % Load parameters from metadata file and load all raw data

  fprintf('...load metadata and raw image data\n')

  % input directory with raw data and output directory for preprocessed image
  % data and parameter file
  if is_executed_as_script
    rootdir = './data/';
  else
    rootdir = dataparams.rootdir;    
  end
  mydatadir = strcat(rootdir,SIMdataset);
  if ~exist(mydatadir, 'dir')
    mkdir(mydatadir)
  end

  % load .mat file with metadata, this file must be supplied by the user, and
  % can be generated, by example, with the script SIMdata_reformat_omx.mat
  % for OMX type data, or with the script SIMdata_reformat_zeiss.m for Zeiss
  % type data
  loadfilename = strcat(mydatadir,'\metadata.mat');
  load(loadfilename,'SIMparams')

  % extract dimensions of the overall 7D data array
  numpixelsx = SIMparams.numpixelsx;
  numpixelsy = SIMparams.numpixelsy;
  numsteps = SIMparams.numsteps;
  numfocus = SIMparams.numfocus;
  numchannels = SIMparams.numchannels;
  numframes = SIMparams.numframes;
  numangles = SIMparams.numangles;

  % read-in primary image data, it is assumed these data files have been
  % prepared by the user or generated by, for example, the script
  % SIMdata_reformat_omx.mat for OMX type data, or SIMdata_reformat_zeiss.mat
  % for Zeiss type data; alernatively, the user can define his/her own I/O,
  % as long as it results in the right 7D array
  allimages_in = zeros(numpixelsx,numpixelsy,numsteps,numfocus,numchannels,numframes,numangles);
  for jangle = 1:numangles
    for jframe = 1:numframes
      for jchannel = 1:numchannels
        for jfocus = 1:numfocus
          for jstep = 1:numsteps
            filelabel = strcat('_jstep',num2str(jstep),'_jfocus',num2str(jfocus),'_jchannel',num2str(jchannel),'_jframe',num2str(jframe),'_jangle',num2str(jangle));
            datafilename = strcat(mydatadir,'\imagedata',filelabel,'.mat');
            load(datafilename,'imagedata')
            allimages_in(:,:,jstep,jfocus,jchannel,jframe,jangle) = double(imagedata);
          end
        end
      end
    end
  end

  %% Section 2 - preprocessing options
  % - possible crop in numpixelsx x numpixelsy x numfocus x numchannel x numframes dimensions,
  % default is no crop
  % - in case of image structure extending to the rim of the image Fourier
  % streaking will occur, this can be suppressed by a windowing operation,
  % the window size can be adjusted per dataset, default is windowsize = 0.15
  % - the periodic boundary condition of the FT in the axial direction can
  % sometimes result in z-wrapping artefacts, this may be avoided by 
  % additional fictitious layers, constructed by fading out the final layer,
  % fading in the first layer and adding a uniform noisy layer to keep 
  % overall intensity constant, numguards = # additional layers, default = 0  
  % - a drift correction can be made, per group of numsteps images with an 
  % all to one registration per focus layer and per color channel, default is
  % 0 (no drift correction)
  % - a random binomial data split can be made and processed downstream for
  % validation of the noise model or for single image noise estimation,
  % default is 0 (no split)
  % - the intensities per angle, focus layer, and frame can be equalized at
  % the level of the lowest intensity without compromising shot noise 
  % statistics using the binomial data splitting method, default is 0 (no
  % equalization)

  if is_executed_as_script

    % default parameters
    SIMparams.cropx = 1:numpixelsx;
    SIMparams.cropy = 1:numpixelsy;
    SIMparams.cropfocus = 1:numfocus;
    SIMparams.cropchannels = 1:numchannels;
    SIMparams.cropframes = 1:numframes;

    SIMparams.numguards = 0; % additional fictitious focus layers for avoiding z-wrapping artefacts 
    SIMparams.numblends = 0; % number of peripheral layers of image stack that are blended for avoiding z-wrapping artefacts, must be < numfocus/2
    windowsize = 0.15; % xy size of cosine edge as fraction of total xy data square size
    equalizeintensities = 0; % making the average intensity per angle, focus layer, and frame equal
    driftcorrection = 0; % make a drift correction or not
    makesplit = 0; % possible random binomial datasplit 
    
    switch SIMdataset
      case 'GFP_zyxin'
        SIMparams.cropx = 78:589; % x-coordinates of crop from 1002x1002 sized total image
        SIMparams.cropy = 1:512; % y-coordinates of crop from 1002x1002 sized total image
        SIMparams.cropframes = 1:10;
        makesplit = 1; % make random binomial data split
        windowsize = 0.125; % xy size of cosine edge as fraction of total xy data square size
      case 'nano_test_structures_chirp'
        windowsize = 0.0; % xy size of cosine edge as fraction of total xy data square size
      case 'nano_test_structures_finepitch'
        windowsize = 0.0; % xy size of cosine edge as fraction of total xy data square size
      case 'mCherry_synaptonemal_complex'
        windowsize = 0.0; % xy size of cosine edge as fraction of total xy data square size
      case 'invitrogen_test_slide'
        % big crop
        SIMparams.cropx = 121:888; % x-coordinates of crop from 1002x1002 sized total image
        SIMparams.cropy = 121:888; % y-coordinates of crop from 1002x1002 sized total image
    %     % crop to just the nucleus
    %     SIMparams.cropx = 350:733; % x-coordinates of crop from 1002x1002 sized total image
    %     SIMparams.cropy = 310:693; % y-coordinates of crop from 1002x1002 sized total image
        windowsize = 0.125; % xy size of cosine edge as fraction of total xy data square size
      case '20150724_Tub-6_512_T30_30ms_01'
        makesplit = 1; % make random binomial data split
      case '20150724_Tub-6_512_T30_10ms_02'
        makesplit = 1; % make random binomial data split
      case '20150724_Tub-6_512_T10_10ms_03'
        makesplit = 1; % make random binomial data split
      case '20150724_Tub-6_512_T1_30ms_04' 
        makesplit = 1; % make random binomial data split
      case '20171101_3_C127_H3K4me3-rbA488_DAPI_07'
        SIMparams.cropx = 1:256; % x-coordinates of crop from 512x512 sized total image
        SIMparams.cropy = 1:256; % y-coordinates of crop from 512x512 sized total image
        windowsize = 0.0; % xy size of cosine edge as fraction of total xy data square size
      case '20180709_HeLa_H2B-GFP_37C_520_T30_10ms_d2s_06'
        SIMparams.numguards = 14; % # additional fictitious focus layers
        SIMparams.numblends = 0; % blend first and last numblends layers
    %     SIMparams.cropframes = 1:1;
        windowsize = 0.0; % xy size of cosine edge as fraction of total xy data square size
      case '20171103_HeLa_H2B-GFP_RT_OP30_514_d3s_07'
        SIMparams.numguards = 0; % # additional fictitious focus layers
        windowsize = 0.0; % xy size of cosine edge as fraction of total xy data square size
      case '20190809_4c-EdU_516_fr-r-g-b_02'
        SIMparams.cropx = 257:512; % x-coordinates of crop from 512x512 sized total image
        SIMparams.cropy = 18:273; % y-coordinates of crop from 512x512 sized total image
        windowsize = 0.0; % xy size of cosine edge as fraction of total xy data square size
      case 'MSPFISH_DlgGFP_p2s3l_016'
        SIMparams.cropx = 129:512; % x-coordinates of crop from 512x512 sized total image
        SIMparams.cropy = 129:512; % y-coordinates of crop from 512x512 sized total image
        windowsize = 0.0; % xy size of cosine edge as fraction of total xy data square size
    end
  else
    SIMparams.cropx = dataparams.cropx; % x-coordinates of crop
    SIMparams.cropy = dataparams.cropy; % y-coordinates of crop
    SIMparams.cropfocus = dataparams.cropfocus; % z-coordinates of crop
    SIMparams.cropchannels = dataparams.cropchannels; % lambda-coordinates of crop
    SIMparams.cropframes = dataparams.cropframes; % t-coordinates of crop
    SIMparams.numguards = dataparams.numguards; % additional fictitious focus layers for avoiding z-wrapping artefacts 
    SIMparams.numblends = dataparams.numblends; % number of peripheral layers of image stack that are blended for avoiding z-wrapping artefacts, must be < numfocus/2
    windowsize = dataparams.windowsize; % xy size of cosine edge as fraction of total xy data square size
    equalizeintensities = dataparams.equalizeintensities; % making the average intensity per angle, focus layer, and frame equal
    driftcorrection = dataparams.driftcorrection; % make a drift correction or not
    makesplit = dataparams.makesplit; % possible random binomial datasplit
  end

  numpixelsx = length(SIMparams.cropx);
  numpixelsy = length(SIMparams.cropy);
  numfocus = length(SIMparams.cropfocus);
  numchannels = length(SIMparams.cropchannels);
  numframes = length(SIMparams.cropframes);
  SIMparams.numpixelsx = numpixelsx;
  SIMparams.numpixelsy = numpixelsy;
  SIMparams.numfocus = numfocus;
  SIMparams.numchannels = numchannels;
  SIMparams.numframes = numframes;

  allimages_in = allimages_in(SIMparams.cropx,SIMparams.cropy,:,SIMparams.cropfocus,SIMparams.cropchannels,SIMparams.cropframes,:);
  SIMparams.allwavelengths = SIMparams.allwavelengths(SIMparams.cropchannels);
  SIMparams.allwavelengthsex = SIMparams.allwavelengthsex(SIMparams.cropchannels);
  SIMparams.allpatternpitch_init = SIMparams.allpatternpitch_init(SIMparams.cropchannels);

  % add fictitious focus layers for avoiding z-wrapping artefacts
  if SIMparams.numguards>0
    allimages_add = zeros(numpixelsx,numpixelsy,numsteps,SIMparams.numguards,numchannels,numframes,numangles);
    allimages_in = cat(4,allimages_in,allimages_add);
    clear allimages_add
    for jangle = 1:numangles
      for jframe = 1:numframes
        for jchannel = 1:numchannels
          for jstep = 1:numsteps
            imstack_in = reshape(allimages_in(:,:,jstep,1:numfocus,jchannel,jframe,jangle),[numpixelsx numpixelsy numfocus]);
            imstack_out = blur_extend(imstack_in,SIMparams.numguards);
            allimages_in(:,:,jstep,:,jchannel,jframe,jangle) = imstack_out;
          end
        end
      end
    end
    numfocus = numfocus+SIMparams.numguards;
    SIMparams.numfocus = numfocus;
  end

  % blend first and last few layers to avoid z-wrapping artefacts
  if SIMparams.numblends>0
    for jangle = 1:numangles
      for jframe = 1:numframes
        for jchannel = 1:numchannels
          for jstep = 1:numsteps
            imstack_in = reshape(allimages_in(:,:,jstep,:,jchannel,jframe,jangle),[numpixelsx numpixelsy numfocus]);
            imstack_out = blend_stack(imstack_in,SIMparams.numblends);
            allimages_in(:,:,jstep,:,jchannel,jframe,jangle) = imstack_out;
          end
        end
      end
    end
  end

  %% Section 3 - visual check of images

  if is_executed_as_script
    fprintf('...initial visual check of images\n')
    showsteps = 3;
    showfocus = 1:numfocus;
    showchannels = 1:numchannels;
    showframes = 1;
    showangles = 2;

    for jchannel = showchannels
      for jfocus = showfocus
        for jangle = showangles
          for jstep = showsteps
            for jframe = showframes
              figure
    %           ftim = abs(fftshift(fft2(squeeze(allimages_in(:,:,jstep,jfocus,jchannel,jtime,jangle)))));
    %           imagesc(log(ftim))
              imagesc(squeeze(allimages_in(:,:,jstep,jfocus,jchannel,jframe,jangle)))
              axis square
              colormap bone
              colorbar
              title(strcat('jstep = ',num2str(jstep),', jchannel = ',num2str(jchannel),', jframe = ',num2str(jframe),', jangle = ',num2str(jangle)))
            end
          end
        end
      end
    end
  end
  
  %%
  % Make offset and gain correction

  fprintf('...gain and offset correction for obtaining image data in detected photon counts\n')

  for jchannel = 1:numchannels
    allimages_in(:,:,:,:,jchannel,:,:) = (allimages_in(:,:,:,:,jchannel,:,:)-SIMparams.offset(jchannel))/SIMparams.gain(jchannel);

    fprintf('minimum pixel value = %5.1f photons\n',min(allimages_in(:)))
    fprintf('maximum pixel value = %5.1f photons\n',max(allimages_in(:)))
  end

  % correct for possible too low (negative) pixel values
  thresh = 1;
  allimages_in(allimages_in<thresh) = thresh;

  %%
  % intensity sum over x,y,phase for qualitative bleaching assessment, the
  % output is an, in principle, 4D array, according to z,channel,frame,angle

  fprintf('...compute sum intensities for assessing photobleaching\n')

  allints = zeros(numfocus,numchannels,numframes,numangles);
  for jchannel = 1:numchannels
    for jframe = 1:numframes
      for jfocus = 1:numfocus
        for jangle = 1:numangles
          intsy = squeeze(allimages_in(:,:,:,jfocus,jchannel,jframe,jangle));
          allints(jfocus,jchannel,jframe,jangle) = sum(intsy(:));
        end
      end
    end
  end

  % make plots of sum intensity vs defocus
  if numfocus>1
    allanglelegends = cell(numangles,1);
    for jangle = 1:numangles
      allanglelegends{jangle} = strcat('angle #',num2str(jangle));
    end
    for jchannel = 1:numchannels
      for jframe = 1:numframes
        figure
        plot(squeeze(allints(:,jchannel,jframe,:)),'-o')
        xlabel('focus level')
        ylabel('sum intensity')
        legend(allanglelegends)
        title(strcat('jchannel = ',num2str(jchannel),', jframe = ',num2str(jframe)))
      end
    end
  end

  %%
  % Make modulation estimate in the raw images and compute the Modulation
  % Contrast to Noise Ratio (MCNR) from these modulation values. This
  % concept derives from Ball et al, Sci Rep. 5, 15915 (2015). Here we use
  % the sinusoidal fit a+b1*cos(2*pi*j/N+phi1)+b2*cos(4*pi*j/N+phi2)
  % per pixel for phases j = 1,2,...,N, where phi1 and phi2 are offsets. The
  % noise is typically N = sqrt(a). The modulation is assessed as
  % M = 2*sqrt(b1^2+b2^2), so MCNR = M/N.
  % The outcome is an, in principle 5D, array according to x,y,z,channel,frame

  fprintf('...modulation contrast to noise ratio in raw images\n')

  debugmode = 0;
  [MCNR_ims,allmodulations] = do_modulationcheck(allimages_in,debugmode);

  % compute average MCNR over foreground pixels selected with histogram thresholding
  mcnrprct = 7.5;
  averageMCNR_foreground_top = zeros(numfocus,numchannels,numframes);
  for jfocus = 1:numfocus
    for jchannel = 1:numchannels
      for jframe = 1:numframes
        MCNRslice = squeeze(MCNR_ims(:,:,jfocus,jchannel,jframe));
        MCNRhivals = prctile(MCNRslice(:),[100-mcnrprct 100]);
        averageMCNR_foreground_top(jfocus,jchannel,jframe) = mean(MCNRhivals);
      end
    end
  end

  % compute average MCNR over foreground pixels selected with Otsu thresholding
  averageMCNR_foreground_otsu = zeros(numfocus,numchannels,numframes);
  for jfocus = 1:numfocus
    for jchannel = 1:numchannels
      for jframe = 1:numframes
        MCNRslice = squeeze(MCNR_ims(:,:,jfocus,jchannel,jframe));
        [MCNRmask,segment_threshold] = otsuthreshold(MCNRslice);
        MCNRslice = MCNRmask.*MCNRslice;
  %       MCNRslice = reshape(MCNRslice,[numpixelsx*numpixelsy 1]);
  %       MCNRslice = MCNRslice(MCNRslice>=segment_threshold);
        MCNRslice(MCNRslice<eps) = [];
        averageMCNR_foreground_otsu(jfocus,jchannel,jframe) = mean(MCNRslice(:));
      end
    end
  end

  % plot through-focus average of foreground pixels
  if numfocus>1
    for jchannel = 1:numchannels
      for jframe = 1:numframes
        figure
        box on
        hold on
        plot(averageMCNR_foreground_top(:,jchannel,jframe),'-o')
        plot(averageMCNR_foreground_otsu(:,jchannel,jframe),'-o')
        xlabel('focus level')
        ylabel('average of foreground MCNR values in image')
        legend('foreground by top pixel values','foreground by Otsu threshold')
      end
    end
  end

  averageMCNR_foreground = averageMCNR_foreground_top;
  % averageMCNR_foreground = averageMCNR_foreground_otsu;

  % store results in mat file
  savefilename = strcat(mydatadir,'\MCNRimages.mat');
  save(savefilename,'MCNR_ims','allmodulations','averageMCNR_foreground');

  %%
  % Use random binomial windowing for a number of purposes:
  % - ensure periodic boundary conditions in xy/avoid Fourier streaking
  % - equalize overall intensity over all angles (optional)
  % - do all this while preserving Poisson-statistics
  % This is done in the function do_binosplit.m using a mask variable window.
  % The assumed noise on allimages_in is Poissonian (shot noise), the split
  % is done according to the binomial distribution on the rounded
  % photo-electron counts, the remainder in [-0.5,0.5] is split using the
  % uniform distribution.
  %
  % No windowing is applied in the z-direction, because:
  % - The number of focal slices can be too limited to make a smooth transition
  % to zero.
  % - Forcing an entire focal slice to zero is not in agreement with 
  % widefield image formation and can give rise to artefacts.
  % - The images are blurred very much close to the upper and lower slices
  % due to the defocus of the object of interest, and due to lack of pattern
  % modulation because of spherical aberration, so no axial streaking of
  % substantial interest may be expected to appear.
  % - Any axial streaking that is left is filtered out anyway by the 
  % filtering with the widefield OTF, which has the "missing cone".
  %

  fprintf('...random binomial windowing\n')

  if (windowsize>eps)||equalizeintensities
    window = get_window2D(numpixelsx,numpixelsy,windowsize); % compute 2D window function

    % compute sum intensities for normalization factors
    if equalizeintensities
      tempallimages = zeros(size(allimages_in));
      for jangle = 1:numangles
        for jframe = 1:numframes
          for jchannel = 1:numchannels
            for jfocus = 1:numfocus
              for jstep = 1:numsteps
                tempallimages(:,:,jstep,jfocus,jchannel,jframe,jangle) = window.*squeeze(allimages_in(:,:,jstep,jfocus,jchannel,jframe,jangle));
              end
            end
          end
        end
      end
      tempallints = reshape(sum(sum(sum(tempallimages,1),2),3),[numfocus,numchannels,numframes,numangles]);
      clear tempallimages
    end

    for jangle = 1:numangles
      fprintf('...processing angle %1.0f\n',jangle)
      for jframe = 1:numframes
        fprintf('...processing frame %1.0f\n',jframe)
        for jchannel = 1:numchannels
          fprintf('...processing channel %1.0f\n',jchannel)
          for jfocus = 1:numfocus
            % compute normalization factors from sum intensities
            if equalizeintensities
              temptempallints = squeeze(tempallints(:,jchannel,:,:));
              normfac = min(temptempallints(:))/tempallints(jfocus,jchannel,jframe,jangle);
            end
            % apply the random binomial windowing with the function do_binosplit.m
            for jstep = 1:numsteps
              tempim = squeeze(allimages_in(:,:,jstep,jfocus,jchannel,jframe,jangle));
              if equalizeintensities
                [allimages_in(:,:,jstep,jfocus,jchannel,jframe,jangle),~] = do_binosplit(tempim,normfac*window);
              else
                [allimages_in(:,:,jstep,jfocus,jchannel,jframe,jangle),~] = do_binosplit(tempim,window);
              end
            end
          end
        end
      end
    end
  end

  %%
  % make a drift correction per group of numsteps images with an all to one
  % registration per focus layer and per color channel

  if driftcorrection

    fprintf('...drift correction\n')

    sumimages = reshape(sum(allimages_in,3),[numpixelsx numpixelsy numfocus numchannels numframes numangles]);
    alldrifts = zeros(2,numfocus,numchannels,numframes,numangles);
    for jfocus = 1:numfocus
      for jchannel = 1:numchannels
        imageref = squeeze(sumimages(:,:,jfocus,jchannel,1,1));
        for jframe = 1:numframes
          for jangle = 1:numangles
            tempim = squeeze(sumimages(:,:,jfocus,jchannel,jframe,jangle));
            driftvec = findshift(imageref,tempim,'iter');
            alldrifts(:,jfocus,jchannel,jframe,jangle) = driftvec;
            for jstep = 1:numsteps
              tempim = squeeze(allimages_in(:,:,jstep,jfocus,jchannel,jframe,jangle));
              allimages_in(:,:,jstep,jfocus,jchannel,jframe,jangle) = im2mat(shift(tempim,driftvec));
            end
          end
        end
      end
    end

    fprintf('minimum pixel value = %5.1f photons\n',min(allimages_in(:)))
    fprintf('maximum pixel value = %5.1f photons\n',max(allimages_in(:)))

    % correct for possible too low (negative) pixel values
    thresh = 1;
    allimages_in(allimages_in<thresh) = thresh;
  end

  %%
  % Make a binomial random image split for single-image noise estimation in
  % downstream processing. This is done in the function do_binosplit.m.The
  % assumed noise on allimages_in is Poissonian shot noise, the split is done
  % according to the binomial distribution on the rounded photo-electron
  % counts, the remainder in [-0.5,0.5] is split using the uniform
  % distribution.

  if makesplit

    fprintf('...make random binomial data split\n')
    psplit = 0.5;
    [allimages_in_splitA,allimages_in_splitB] = do_binosplit(allimages_in,psplit);

    % make visual check of images
    checksplit = 0;
    if checksplit
      for jstep = showsteps
        for jfocus = showfocus
          for jchannel = showchannels
            for jframe = showframes
              for jangle = showangles
                scrsz = [1 1 1366 768];
                figure
                set(gcf,'Position',round([0.1*scrsz(3) 0.2*scrsz(4) 0.8*scrsz(3) 0.45*scrsz(4)]));
                subplot(1,3,1)
                imagesc(squeeze(allimages_in(:,:,jstep,jfocus,jchannel,jframe,jangle)))
                axis square
                colormap bone
                colorbar
                subplot(1,3,2)
                imagesc(squeeze(allimages_in_splitA(:,:,jstep,jfocus,jchannel,jframe,jangle)))
                axis square
                colormap bone
                colorbar
                subplot(1,3,3)
                imagesc(squeeze(allimages_in_splitB(:,:,jstep,jfocus,jchannel,jframe,jangle)))
                axis square
                colormap bone
                colorbar
              end
            end
          end
        end
      end
    end
  end

  %%
  % get widefield images by summing over all pattern phases and angles
  %

  fprintf('...generating widefield images\n')
  [widefield,ftwidefield] = get_widefield(allimages_in);

  % make SSNR estimate for widefield image
  % observations on OMX 3D datasets:
  % - effects of axial Fourier streaking are not suppressed
  % - effects of fixed pattern noise seem present at qz=0 plane
  refitgain = 1; % flag indicating recalibration of gain due to possible image scaling errors 
  allwfsumsignal = zeros(numchannels,numframes);
  allSSNRest_wf = zeros(numpixelsx,numpixelsy,numfocus,numchannels,numframes);
  numbins = round(sqrt(numpixelsx*numpixelsy)/2);
  allSSNRest_ring_wf = zeros(numbins,numfocus,numchannels,numframes);
  for jchannel = 1:numchannels
    for jframe = 1:numframes
      widefieldtmp = squeeze(widefield(:,:,:,jchannel,jframe));
      allwfsumsignal(jchannel,jframe) = sum(widefieldtmp(:));
      wavelength = SIMparams.allwavelengths(jchannel);
      debugmode = 0;
      [SSNRest_wf,SSNRest_ring_wf] = get_widefieldSSNR(widefieldtmp,allwfsumsignal(jchannel,jframe),numbins,SIMparams.rawpixelsize,SIMparams.NA,wavelength,SIMparams.refmed,refitgain,debugmode);
      allSSNRest_wf(:,:,:,jchannel,jframe) = SSNRest_wf;
      allSSNRest_ring_wf(:,:,jchannel,jframe) = SSNRest_ring_wf;
    end
  end
  SIMparams.allwfsumsignal = allwfsumsignal; % store overall sum photon count

  % store results in mat files
  savefilename = strcat(mydatadir,'\SIMprocessedresults_widefield.mat');
  save(savefilename,'widefield','ftwidefield','allSSNRest_wf','allSSNRest_ring_wf');

  % additional split widefield images in case of random binomial data splitting
  if makesplit
    [widefield,ftwidefield] = get_widefield(allimages_in_splitA);
    savefilename = strcat(mydatadir,'\SIMprocessedresults_widefield_splitA.mat');
    save(savefilename,'widefield','ftwidefield');
    [widefield,ftwidefield] = get_widefield(allimages_in_splitB);
    savefilename = strcat(mydatadir,'\SIMprocessedresults_widefield_splitB.mat');
    save(savefilename,'widefield','ftwidefield');
  end

  %%
  % Save parameters and image data to mat-file. The parameters are stored in
  % the struct SIMparams.

  fprintf('...save parameters and image data\n')

  SIMparams.driftcorrection = driftcorrection; % possible drift correction
  if SIMparams.driftcorrection
    SIMparams.alldrifts = alldrifts; % estimated drifts (in pixels)
  end
  SIMparams.makesplit = makesplit; % possible random binomial datasplit
  SIMparams.equalizeintensities = equalizeintensities; % possible equalization of intensities for bleaching correction
  SIMparams.allints = allints; % sum intensities for bleaching estimation
  SIMparams.averageMCNR_foreground = averageMCNR_foreground; % MCNR peak level for modulation quality estimation
  SIMparams.windowsize = windowsize; % percentage of xy image size for anti Fourier streak window

  % save parameters
  savefilename = strcat(mydatadir,'\SIMparamsfile.mat');
  save(savefilename,'SIMparams')

  % save preprocessed image data, including additional data in case of
  % random binomial data splitting
  for jangle = 1:numangles
    for jframe = 1:numframes
      for jchannel = 1:numchannels
        for jfocus = 1:numfocus
          for jstep = 1:numsteps
            filelabel = strcat('_jstep',num2str(jstep),'_jfocus',num2str(jfocus),'_jchannel',num2str(jchannel),'_jframe',num2str(jframe),'_jangle',num2str(jangle));
            savefilename = strcat(mydatadir,'\preprocessedimages',filelabel,'.mat');
            imagedata = allimages_in(:,:,jstep,jfocus,jchannel,jframe,jangle);
            save(savefilename,'imagedata')
            if makesplit
              savefilename = strcat(mydatadir,'\preprocessedimages_splitA',filelabel,'.mat');
              imagedata = allimages_in_splitA(:,:,jstep,jfocus,jchannel,jframe,jangle);
              save(savefilename,'imagedata')
              savefilename = strcat(mydatadir,'\preprocessedimages_splitB',filelabel,'.mat');
              imagedata = allimages_in_splitB(:,:,jstep,jfocus,jchannel,jframe,jangle);
              save(savefilename,'imagedata')
            end
          end
        end
      end
    end
  end

end